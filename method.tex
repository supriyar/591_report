

\subsection{Call-Graph Analysis}



\subsection{Bandwidth Limitation}
As stated in Section \ref{smart_code} we wanted to include the bandwidth in our scheduling decision making logic. To get the current bandwidth conditions avaialble to the device, we ran a daemon similar in nature to the \texttt{tcpmux} daemon used in COMET. The \texttt{tcpmux} daemon helps in communication between the client and server and also in providing the latest RTT values to the decision engine. When the decision engine is invoked for the first time, the engine \texttt{connect}s to the \texttt{tcpmux} daemon running locally and gets the latest RTT value. This RTT value is obtained only once during the lifetime of the thread. We implemented a similar daemon that would provide for the latest bandwidth conditions. The bandwidth daemon internally ran the \texttt{iperf} tool to estimate the bandwidth. The daemon was configured to recalculate the bandwidth periodically after every 10 seconds. 

To limit the bandwidth available to the device, we explored two options - \texttt{dummynet} and \texttt{tc}. Owing to certain kernel module incompatabilities with \texttt{dummynet}, we used \texttt{tc} to limit the bandwidth for our experiments. \texttt{tc} is not available immediately in production devices and we had to rebuild the kernel to provide support for \texttt{tc}. After tc was eanbled in the kernel, we used the Hierarchical Token Bucket (HTB) queuing discipline to limit both the upload and download bandwidth. We used a shell script to dynamically change the bandwidth over different executions of the application. 

Studying the code, we observed that the data to be transferred is collected much after a decision has been made to migrate it. Thus, the data size to be transferred is available just before a \texttt{write} call to the socket. We implemented our decision logic at this stage in the application's execution. We query the bandwidth daemon to get the latest avaialble bandwidth. Next, we compare the size of data to be transferred to a threshold derived from the latest bandwidth and then take a final decision whether to offload the thread or not. The different threshold that we used are discussed in the Evaluation Section. (\ref{eval})
