In this paper, we incorporated compiler based static information and DDMS based dynamic statistics to formulate two heuristics for intelligent scheduling of thread migration on COMET. COMET offloads threads to a remote server when the time of execution of non-native code exceeds the threshold (based on sync time and RTT). Although, the authors have shown considerable performance improvement in the execution time of applications that benefit from increased computation power, the scheduling fails to take into account the application characteristics. These characteristics sometimes cause the offloaded thread to abort and return soon after the thread is migrated. The communication overhead involved degrades the overall performance of the application. Secondly, since the offloading procedure waits for the threshold to be achieved on the client before offloading, COMET loses the opportunity the offload when it could have, thereby not utilizing the compute resources to the fullest.
Both our offloading heuristics are aimed at addressing these limitations. By analyzing the applications we identified the application characteristics with respect its native method calls. Both heuristics can be used in conjunction to enhance the application performance.
We believe that the offloading decisions can be even more precise if the VM can store the last execution time of the methods of interest rather than relying on an external tool like DDMS to provide the numbers.

We believe that the offloading decisions can be even more precise if the VM can store the last execution time of the methods of interest rather than relying on an external tool like DDMS to provide the numbers. Moreover, we are currently manually annotating the methods as safe or unsafe to offload based on our
heuristics analysis. This is not feasible for a practical scenario and it can ideally be implemented by storing the list of such methods in application package.

The current implementation of COMET takes a weighted average of the last sync times to arrive at the current sync time, which we think can be experimented with to increase its accuracy. In addition to this, the current implementation of bandwidth check shuts down the socket after calculating the size of the state to be migrated, if it decides to not offload. Once the socket is closed, we use the thread recovery mechanism to rebuild the state of the thread and continue its execution locally. This short-circuiting step incurs the recovery overhead and can be worked on to immediately resume the thread locally if the bandwidth check decides against offloading.

